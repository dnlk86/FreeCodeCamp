- Variables declared with the let keyword inside a block, statement, or expression, have a scope limited to that block, statement, 
    or expression:
        for (let i=0: i < 100; i++) {
            ... some code;
        }
        In this case i leaves only inside the for loop. If var is used instead to declare a variable, that variable is declared globally,
        or locally if declared inside a function. 
- Some devs use const to declare all variables and use let just in those cases when they know that they need to reassign a variable.
    Objects (including arrays and functions) assigned to a variable using const are still mutable, const only prevents reassignment 
    of the variable identifier.
- Const doesn't prevent data mutation, to do that there is the Object.freeze(someObj) function that throws an error in such cases.
- Arrow functions are used to write anonymous functions. When there's no function body and only a return val the syntax is:
    const myFunc = () => "value";
- It is also possible to pass parameters to arrow functions, if there's only one param then the parentheses are not needed:
    const myFunc = myParam => myParam*2;
    In case of more params parentheses are needed.
- Default parameters kick in when an argument is not passed to the function when called: 
    const myFunc = (someParam = "myDefault) => returnSomething;
- Rest paramenters are used to create functions that take a variable number of arguments. These arguments are stored in an array 
    that can be accessed later from inside the function: const myFunc = (...args) => returnSomething;
    The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the 
    parameters array.
- The spread operator allows to expand (spread) arrays and other expressions in places where multiple parameteres or elements are
    expected:
        const arr = [1,2,3,4];
        const maximus = Math.max(...arr);
    ...arr returns an unpacked array, it spreads the array since Math.max() expects comma separated arguments, but not an array.
    The spread operator only works in place, like in an argument of a function or in a literal array, but doesn't work in variable
    assignments:
        const spreaded= ...arr; // does not work
- Destructuring assigment is used for extracting values from an object:
    const user = { name: 'John Doe', age: 34 };     // That's the object
    const {name, age} = user;                       // That's the destructuring syntax
- Destructuring assigment can also be used to assign new variable names when extracting values:
    const {name: userName, age: userAge} = user;    // Read as: get the value of user.name and assign it to a new variable named 
                                                        userName and so on.
- Destructuring can also be applied to nested objects.
- Spread operator and array destructuring may look similar, but the second one unpacks all the content of an array into a comma
    separated list, that means that it is not possible to pick single elements to assign to variables. On the other hand
    destructuring allows exactly that.
- It is possible to combine array destructuring and rest parameter to extract and place in a new variable the elements of an array 
    from a certain value till the end with the following syntax:
        const [a,b, ...arr] = [1,2,3,4,5,6];
        in this case a = 1, b = 2 and arr = [3,4,5,6]. The rest operator can be used only as last element in the destructuring.
- In cases when an object is passed as an argument of a function in order to perform some actions to its elements, it is also possible.
    to operate a destructuring assigment directly in the parameters declaration and pass only the properties really needed instead of
    of the entire object:
        const myFunc = function({objProp1, objProp2, ..., objPropN}) {
            something something.
        }
- Template literal is a special type of string that allows to create complex strings easy.