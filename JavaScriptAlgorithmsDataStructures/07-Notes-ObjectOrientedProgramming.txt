- Real world objects are tangible things people can interact with.
- Objects in JS are used to model real-wold objects. They have properties with certain values and particular behaviors.
- The dot (.) notation used on the objects name followed by the name of the property grants access to the value stored for that property
    (myObj.propName).
- Methods are properties that are functions, those add different behavior to the object.
- Calling properties in object's methods directly with the obj name using the dot notation may cause problems. If the obj name is
    changed, then also the reference to the property inside the method has to be changed. A way to avoid this is by referencig to the
    object using the keyword "this":    this.propName.
- Constructors are functions that create new objects, they define properties and behaviors and do not return a value like a function might.
- Constructors are defined with capitalized names to distinguish them from other functions.
- Constructors use the keyword this to set properties of the object, this is a reference to the obj that is being created. 
- The "new" operator needs to be used when a constructor is invoked:
    const myDog = new Dog();    // this tell JS to create an instance of the obj Dog and store it in the variable myDog.
- Constructors like every function can accept arguments, so when the constructor is invoked the user can define right away
    the values of some object's properties (without needing to set those properties later with the dot notation).
- When a constructor is invoked the new object created is called an instance of the constructor (the constructor is like a cookie cutter).
    To verify if a certain object is an istance of a contructor there is the instanceof operator:
        doggy instanceof Dog;       // this evaluates to true or false
- The properties defined directly in the instance object (in the constructor?) are called own properties. Meaning that each different
    instance of the same object will have its own copies of these properties. This number of copied properties grows as fast as the number
    of objects instances grows.
- The use of prototype properties reduces the duplication of code. Properties in the prototype of an object are shared among all the
    instances of the object itself:     Dog.prototype.numLegs = 4;      // this prop is shared among all the dogs.
- Prototype properties are part of the constructor.
- To recap: Own properties are defined directly on the object instance itself. And prototype properties are defined on the prototype.
- To mention that the constructor itself is a property: beable.constructor === Dog evaluates to true, Dog is the constr. property.
- Properties can be added to the prototype one at the time, but after a few this process becomes tedious. Another way is to set the
    prototype to a new object instead that already contains the properties. This way the props are added all at once:
        Dog.prototype = {
            numlegs: 4,
            something: ...
        }
- By setting the prototype to a new object the constructor property of the object is erased. To avoid that the constructor property
    needs to be manually defined inside the prototype:
        Dog.prototype = {
            constructor: Dog,
            numLegs: 4,
            ...
        }
- An object inherits its prototype directly from the constructor function that created it (just like sons inherit genes from parents).
- All objects in JavaScript (with a few exceptions) have a prototype. Also, an objectâ€™s prototype itself is an object, this means
    that a prototype can have its own prototype:
        Object.prototype.isPrototypeOf(Dog.prototype);      \\ evaluates true
        Dog.prototype.isPrototypeOf(beagle);                \\ evaluates true
- In this prototype chain, Dog is the supertype for beagle, while beagle is the subtype. Object is a supertype for both Dog and beagle. 
    Object is a supertype for all objects in JavaScript. Therefore, any object can use the hasOwnProperty method.